# 计算机通信
![](%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E4%BF%A1/168A1C20-278D-4ED6-9F91-D10E2CC0081F.png)
FTP，HTTP。。。
TCP，UDP
IP
ARP
IEEE 802.2
 [https://blog.csdn.net/buknow/article/details/81148684](https://blog.csdn.net/buknow/article/details/81148684) 

 [https://github.com/Snailclimb/JavaGuide/blob/master/docs/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md](https://github.com/Snailclimb/JavaGuide/blob/master/docs/network/%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BD%2591%25E7%25BB%259C.md) 


 [https://www.zhihu.com/question/22211535/answer/920991154](https://www.zhihu.com/question/22211535/answer/920991154) 


## 三次握手
![](%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E4%BF%A1/4A792188-CE0E-4E57-9E35-026018221AB3.png)
监听/同步已发送状态/同步收到/已建立连接状态
- - - -
为什么3次握手
第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常
第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常
第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常
所以三次握手就能确认双发收发功能都正常，缺一不可。
## 四次挥手
![](%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E4%BF%A1/D73A34D4-AC44-4727-A645-63A7418D1B78.png)
终止等待1/关闭等待/终止等待2/最后确认/时间等待状态
任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。
举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。
- - - -
 为什么最后还要等2MSL？
1. 保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文（回信在路上消耗的最大时间+FIN重新发送的最大时间），接着给出回应报文，并且会重启2MSL计时器。
2. 同时可以防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。
- - - -
为什么握手比挥手多一次？
建立连接时，ACK和SYN一起发送而断开连接时ACK和FIN分开发送
## 输入一个网址到显示HTML
![](%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E4%BF%A1/97075ED3-FFDA-4394-B931-FDD90955FBB1.png)
## 子网掩码
知道主机数求子网数：主机数换成二进制，从后往前取n个零，n为二进制的位数
知道子网求主机数，从前往后取0

#学习/测试#